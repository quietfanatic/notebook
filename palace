#!/usr/bin/perl
package palace;
use strict;
use warnings;
use v5.18;
use bytes;  # Assume everything is UTF-8
use JSON::MaybeXS ':all';
use Carp 'croak';

 # Overridden for testing
our $datadir = 'data';

##### Misc utilities
sub arity_miss {
    my ($got, $wanted) = @_;
    my (undef, undef, undef, $name) = caller 1;
    return $got > $wanted
        ? "Too many parameters passed to $name ($got > $wanted)"
        : "Too few parameters passed to $name ($got < $wanted)";
}

##### Stringy utilities

sub iso_datetime { ($_[5]+1900)."-".($_[4]+01)."-$_[3]T$_[2]:$_[1]:$_[0]Z" }

sub encode_name {
    my ($name) = @_;
    $name =~ s/([\/\\?%*:|"'<>.])/sprintf '%%%02X', ord($1)/eg;
    return $name;
}
sub decode_name {
    my ($name) = @_;
    $name =~ s/%([a-zA-Z0-9]{2})/chr hex $1/eg;
    return $name;
}
sub name_file {
    my $ename = encode_name $_[0];
    return "$datadir/things/$ename.json";
}


##### Validation

 # Ad-hoc, doesn't conform to any standardized schema schema.
our $top_schema = {
    name => 'name',
    uri => 'uri',
    added => 'datetime',
    updated => 'datetime',
    tags => ['name'],
    tagged => ['name'],
    comments => ['string'],
    misc => { '!ANY' => undef },
    '!REQUIRED' => ['name'],
};

 # Returns list of strings.
sub criticize {
    my ($obj, $schema, $path) = @_;
    @_ < 1 and croak arity_miss 0+@_, 1;
    @_ < 2 and $schema = $top_schema;
    @_ < 3 and $path = 'TOP' if @_ < 3;
    @_ > 3 and croak arity_miss 0+@_, 3;
    if (!defined $schema) {
        return ();  # Anything goes
    }
    elsif (ref $schema eq 'HASH') {
        ref $obj eq 'HASH' or return "Value at $path is not an object";
        my @errs;
        for (@{$schema->{'!REQUIRED'}}) {
            if (!exists $obj->{$_}) {
                push @errs, "Missing required property $_ at $path";
            }
        }
        for (keys %$obj) {
            if ($_ =~ /^!/) {
                push @errs, "Key $_ at $path should not begin with a !";
            }
            elsif (exists $schema->{$_}) {
                push @errs, criticize($obj->{$_}, $schema->{$_}, "$path.$_");
            }
            elsif (exists $schema->{'!ANY'}) {
                push @errs, criticize($obj->{$_}, $schema->{'!ANY'}, "$path.$_");
            }
            else {
                push @errs, "Unallowed property $_ at $path";
            }
        }
        return @errs;
    }
    elsif (ref $schema eq 'ARRAY') {
        ref $obj eq 'ARRAY' or return "Value at $path is not an array";
        @$schema == 1 or return "Schema itself is broken at $path";
        my @errs;
        for (0..$#$obj) {
            push @errs, criticize($obj->[$_], $schema->[0], "$path\[$_]");
        }
        return @errs;
    }
    elsif ($schema eq 'name') {
        ref $obj eq '' or return "Value at $path is not a string, let alone a name";
        my @errs;
        if ($obj eq '') {
            push @errs, "Value at $path is too empty to be a name";
        }
        if (length $obj > 200) {
            push @errs, "Value at $path is too long in bytes to be a name (".length($obj)." > 200)";
        }
        if ($obj =~ /^\s/) {
            push @errs, "Value at $path has leading whitespace, and so cannot be a name";
        }
        if ($obj =~ /\s$/) {
            push @errs, "Value at $path has trailing whitespace, and so cannot be a name";
        }
        if ($obj =~ /[\x00-\x1f\x7f]/) {
            push @errs, "Value at $path contains unprintable characters not allowed in a name";
        }
        return @errs;
    }
    elsif ($schema eq 'datetime') {
        ref $obj eq '' or return "Value at $path is not a string, let alone a date";
         # Only taking UTC dates
        $obj =~ /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$/
            or return "Value at $path does not look like a date";
        return ();
    }
    elsif ($schema eq 'uri') {
        ref $obj eq '' or return "Value at $path is not a string, let along a uri";
        $obj =~ /^[a-z]+:\/\// or return "Value at $path does not look like a uri";
        return ();
    }
    elsif ($schema eq 'string') {
        ref $obj eq '' or return "Value at $path is not a string";
         # Not caring about numbers
        return ();
    }
    else {
        return "Schema itself is broken at $path";
    }
}
sub criticize_or_die {
    my ($obj, $mess) = @_;
    @_ == 2 or croak arity_miss 0+@_, 2;
    my @errs = ref $obj eq 'ARRAY' ? criticize(@$obj) : criticize($obj);
    if (@errs) {
        die join("\n    ", $mess, @errs) . "\n";
    }
}

##### Backend

my %items;  # cache

sub have_item {
    my ($name) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    return exists $items{$name} || -e name_file $name;
}

sub read_item {
    my ($name) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    my $filename = name_file $name;
    exists $items{$name} and return $items{$name};
    criticize_or_die [$name, 'name', '(name given to read_item)'], 'Name given to read_item is invalid.';
    -e $filename or croak "$name is not a registered item";
    open my $F, '<', $filename or croak "Could not open $filename for reading: $!";
    local $/;
    my $json = <$F> // croak "Could not read from $filename: $!";
    close $F or croak "Could not close $filename: $!";
    my $item = decode_json $json;
    criticize_or_die $item, "$filename contains invalid data:";
    return $items{$name} = $item;
}

sub write_item {  # TODO: update links, dates
    my ($item) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    criticize_or_die $item, "Provided data did not pass validation:";
    my $filename = name_file $item->{name};
    my $json = encode_json $item;
    open my $F, '>', $filename or croak "Could not open $filename for writing: $!";
    print $F $json or croak "Could not write to $filename: $!";
    $items{$item->{name}} = $item;
    close $F or croak "Could not close $filename: $!";
    return 1;
}

sub delete_item {  # TODO: update links
    my ($name) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    my $filename = name_file $name;
    unlink $filename or croak "Could not delete $filename: $!";
    delete $items{$name};
    return 1;
}

sub update_item {  # TODO: update links, name
    my ($name, $proc) = @_;
    @_ == 2 or croak arity_miss 0+@_, 1;
    criticize_or_die [$name, 'name', '(name given to update_item)'], 'Name given to update_item is invalid.';
    ref $proc eq 'CODE' or croak "Second parameter given to update_item is not a CODE ref.";
    my $item = $proc->(read_item $name);
    criticize_or_die $item, "Item returned from procedure given to update_item did not pass validation:";
    $item->{name} eq $name or croak "Procedure given to update_item changed the item's name (this is NYI).";
    return 1;
}

sub all_names {
    @_ == 0 or croak arity_miss 0+@_, 0;
    my $dir = "$datadir/things";
    opendir my $D, $dir or croak "Could not open $dir: $!\n";
    my @filenames = map {
        /^(.*)\.json$/ ? $1 : ();
    } readdir $D;
    closedir $D or croak "Could not close $dir: $!\n";
    return map decode_name($_), @filenames;
}
sub all_items {
    @_ == 0 or croak arity_miss 0+@_, 0;
    for (all_names) {
        read_item($_);
    }
    return \%items;  # Please don't modify
}

sub validate_everything {
    @_ == 0 or croak arity_miss 0+@_, 0;
    all_items;
    my @errs;
    for (keys %items) {
        $items{$_}{name} eq $_ or push @errs, "Name property of $_ doesn't match its name.";
        my @es = criticize $items{$_};
        if (@es) {
            push @errs, "Invalid data in $_:";
            push @errs, map "    $_", @es;
        }
         # TODO: validate links
    }
    return @errs;
}


##### Raw JSON API

sub raw_add {
    my ($text) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    my $item = decode_json $text;
    have_item $item->{name} and croak "An item named $item->{name} is already registered";
    criticize_or_die $item, "Input to 'add' didn't pass validation.";
    my $filename = name_file $item->{name};
    write_item $item;
}
sub raw_show {
    my ($name) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    my $item = read_item $name;
    return encode_json $item;
}

1;
