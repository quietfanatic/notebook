#!/usr/bin/perl
use strict;
use warnings;
use v5.18;
use bytes;  # Assume everything is UTF-8
use JSON::MaybeXS ':all';
package palace;

 # Overridden for testing
our $data_directory = 'data';

 # Ad-hoc, doesn't conform to any standardized schema schema.
our $top_schema = {
    name => 'name',
    uri => 'uri',
    added => 'datetime',
    updated => 'datetime',
    tags => ['name'],
    tagged => ['name'],
    comments => ['string'],
    misc => { '!ANY' => undef },
    '!REQUIRED' => ['name'],
};

 # Returns list of strings.
sub criticize {
    my ($obj, $schema, $path) = @_;
    $schema = $top_schema if @_ < 2;
    $path = 'TOP' if @_ < 3;
    if (!defined $schema) {
        return ();  # Anything goes
    }
    elsif (ref $schema eq 'HASH') {
        ref $obj eq 'HASH' or return "Value at $path is not an object";
        my @errs;
        for (@{$schema->{'!REQUIRED'}}) {
            if (!exists $obj->{$_}) {
                push @errs, "Missing required property $_ at $path";
            }
        }
        for (keys %$obj) {
            if ($_ =~ /^!/) {
                push @errs, "Key $_ at $path should not begin with a !";
            }
            elsif (exists $schema->{$_}) {
                push @errs, criticize($obj->{$_}, $schema->{$_}, "$path.$_");
            }
            elsif (exists $schema->{'!ANY'}) {
                push @errs, criticize($obj->{$_}, $schema->{'!ANY'}, "$path.$_");
            }
            else {
                push @errs, "Unallowed property $_ at $path";
            }
        }
        return @errs;
    }
    elsif (ref $schema eq 'ARRAY') {
        ref $obj eq 'ARRAY' or return "Value at $path is not an array";
        @$schema == 1 or return "Schema itself is broken at $path";
        my @errs;
        for (0..$#$obj) {
            push @errs, criticize($obj->[$_], $schema->[0], "$path\[$_]");
        }
        return @errs;
    }
    elsif ($schema eq 'name') {
        ref $obj eq '' or return "Value at $path is not a string, let alone a name";
        my @errs;
        if (length $obj > 200) {
            push @errs, "Value at $path is too long to be a name";
        }
        if ($obj =~ /[\x00-\x1f\x7f]/) {
            push @errs, "Value at $path contains unprintable characters not allowed in a name";
        }
        return @errs;
    }
    elsif ($schema eq 'datetime') {
        ref $obj eq '' or return "Value at $path is not a string, let alone a date";
         # Only taking UTC dates
        $obj =~ /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$/
            or return "Value at $path does not look like a date";
        return ();
    }
    elsif ($schema eq 'uri') {
        ref $obj eq '' or return "Value at $path is not a string, let along a uri";
        $obj =~ /^[a-z]+:\/\// or return "Value at $path does not look like a uri";
        return ();
    }
    elsif ($schema eq 'string') {
        ref $obj eq '' or return "Value at $path is not a string";
         # Not caring about numbers
        return ();
    }
    else {
        return "Schema itself is broken at $path";
    }
}

sub iso_datetime { ($_[5]+1900)."-".($_[4]+01)."-$_[3]T$_[2]:$_[1]:$_[0]Z" }

sub encode_name {
    my ($name) = @_;
    $name =~ s/([\/\\?%*:|"'<>.])/sprintf '%%%02X', ord($1)/eg;
    return $name;
}
sub decode_name {
    my ($name) = @_;
    $name =~ s/%([a-zA-Z0-9]{2})/chr hex $1/eg;
    return $name;
}

sub write_data {
    my ($obj) = @_;
    my $filename = encode_name $obj->{name};
    my $text = encode_json $obj;
}

sub add {
    my ($obj) = @_;
    my @errs = criticize($obj);
    if (@errs) {
        return @errs;
    }
    $obj->{created} //= iso_datetime(gmtime);
    $obj->{updated} = iso_datetime(gmtime);
     # TODO: link tags
    my $text = encode_json($obj);
}

1;
