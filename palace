#!/usr/bin/perl
package palace;
use v5.18;
use warnings;
use bytes;  # Assume everything is UTF-8
use JSON::MaybeXS ':all';

sub null () { undef }
sub true () { JSON->true }
sub false () { JSON->false }

sub croak { require Carp; goto &Carp::croak; }
sub clone { require Clone; goto &Clone::clone; }

 # Overridden for testing
our $datadir = 'data';

##### Misc utilities
sub arity_miss {
    my ($got, $wanted) = @_;
    my (undef, undef, undef, $name) = caller 1;
    return $got > $wanted
        ? "Too many parameters passed to $name ($got > $wanted)"
        : "Too few parameters passed to $name ($got < $wanted)";
}

sub slurp {
    my ($fn) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    local $/;
    open my $F, '<', $fn or die "Failed to open $fn for reading: $!\n";
    my $s = <$F> // die "Failed to read from $fn: $!\n";
    close $F or die "Failed to close $fn: $!\n";
    return $s;
}

sub splat {
    my ($fn, $str) = @_;
    @_ == 2 or croak arity_miss 0+@_, 1;
    open my $F, '>', $fn or die "Failed to open $fn for writing: $!\n";
    print $F $str or die "Failed to write to $fn: $!\n";
    close $F or die "Failed to close $fn: $!\n";
}

sub mkdirs {
    for (@_) {
        -d $_ or mkdir $_ or die "Failed to mkdir $_: $!\n";
    }
}

##### Stringy utilities

sub iso_datetime { ($_[5]+1900)."-".($_[4]+01)."-$_[3]T$_[2]:$_[1]:$_[0]Z" }

sub encode_name {
    my ($name) = @_;
    $name =~ s/([\/\\?%*:|"'<>.])/sprintf '%%%02X', ord($1)/eg;
    return $name;
}
sub decode_name {
    my ($name) = @_;
    $name =~ s/%([a-zA-Z0-9]{2})/chr hex $1/eg;
    return $name;
}
sub name_file {
    my $ename = encode_name $_[0];
    return "$datadir/things/$ename.json";
}
sub name_file_backup {
    my $ename = encode_name $_[0];
    return "$datadir/backup/$ename.json";
}


##### Validation

 # Ad-hoc, doesn't conform to any standardized schema schema.
our $index_schema = {
    updated_at => 'datetime!',  # When this file specifically was last changed
    items => { '!' => true, '*' => 'string' },
};
our $item_schema = {
    '?' => true,  # Deleted if null
    name => 'name!',
    created_at => 'datetime!',
    title => 'string',
    origin => {
        uri => 'uri!',
        originated_at => 'datetime',
    },
    tags => ['name', '!'],
    tagged => ['name', '!'],
    contents => ['string', '!'],
    misc => { '*' => '*?' },  # Or perhaps this should be toplevel
};
our $event_schema = {
    id => 'string!',
    started_at => 'datetime!',
    finished_at => 'datetime!',
    source => {
        '!' => true,
        interface => 'string',
        '*' => '*?',
    },
    request => '*?!',
    response => '*?!',
    changes => { '*' => {
        previous => 'string?!',
        item => $item_schema,
    }},
};

sub schema_char {
    my ($schema, $char) = @_;
    return ref $schema eq 'HASH' ? exists $schema->{$char}
         : ref $schema eq 'ARRAY' ? @$schema >= 2 && index($schema->[1], $char) != -1
         : index($schema, $char) != -1;
}

 # Returns list of strings.
sub criticize {
    my ($obj, $schema, $path) = @_;
    @_ < 1 and croak arity_miss 0+@_, 1;
    @_ < 2 and $schema = $item_schema;
    @_ < 3 and $path = 'TOP' if @_ < 3;
    @_ > 3 and croak arity_miss 0+@_, 3;
    if (!defined $schema) {
        return "Schema itself is broken at $path";
    }
    elsif (!defined $obj) {
        schema_char($schema, '?') or return "Value at $path should not be null";
        return ();
    }
    elsif (ref $schema eq 'HASH') {
        ref $obj eq 'HASH' or return "Value at $path is not an object";
        my @errs;
        for (grep schema_char($schema->{$_}, '!'), keys %$schema) {
            if (!exists $obj->{$_}) {
                push @errs, "Missing required property $_ at $path";
            }
        }
        for (keys %$obj) {
            if (exists $schema->{$_}) {
                push @errs, criticize($obj->{$_}, $schema->{$_}, "$path.$_");
            }
            elsif (exists $schema->{'*'}) {
                push @errs, criticize($obj->{$_}, $schema->{'*'}, "$path.$_");
            }
            else {
                push @errs, "Unallowed property $_ at $path";
            }
        }
        return @errs;
    }
    elsif (ref $schema eq 'ARRAY') {
        ref $obj eq 'ARRAY' or return "Value at $path is not an array";
        my @errs;
        for (0..$#$obj) {
            push @errs, criticize($obj->[$_], $schema->[0], "$path\[$_]");
        }
        return @errs;
    }
    elsif ($schema =~ /name/) {
        ref $obj eq '' or return "Value at $path is not a string, let alone a name";
        my @errs;
        if ($obj eq '') {
            push @errs, "Value at $path is too empty to be a name";
        }
        if (length $obj > 200) {
            push @errs, "Value at $path is too long in bytes to be a name (".length($obj)." > 200)";
        }
        if ($obj =~ /^\s/) {
            push @errs, "Value at $path has leading whitespace, and so cannot be a name";
        }
        if ($obj =~ /\s$/) {
            push @errs, "Value at $path has trailing whitespace, and so cannot be a name";
        }
        if ($obj =~ /[\x00-\x1f\x7f]/) {
            push @errs, "Value at $path contains unprintable characters not allowed in a name";
        }
        return @errs;
    }
    elsif ($schema =~ /datetime/) {
        ref $obj eq '' or return "Value at $path is not a string, let alone a date";
         # Only taking UTC dates
        $obj =~ /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$/
            or return "Value at $path does not look like a date";
        return ();
    }
    elsif ($schema =~ /uri/) {
        ref $obj eq '' or return "Value at $path is not a string, let along a uri";
        $obj =~ /^[a-z]+:\/\// or return "Value at $path does not look like a uri";
        return ();
    }
    elsif ($schema =~ /string/) {
        ref $obj eq '' or return "Value at $path is not a string";
         # Not caring about numbers
        return ();
    }
    elsif ($schema =~ /integer/) {
        ref $obj eq '' or return "Value at $path is not a scalar, let alone an integer";
        is_bool($obj) and return "Value at $path is a boolean, not an integer";
        $obj =~ /^\d+$/ or return "Value at $path is not an integer";
        return ();
    }
    elsif ($schema =~ /command/) {
        ref $obj eq '' or return "Value at $path is not a string, let along a command";
        $obj =~ $command_match or return "Value at $path is not a valid command";
        return ();
    }
    elsif ($schema =~ /\*/) {
        return ();  # Anything goes
    }
    else {
        return "Schema itself is broken at $path";
    }
}
sub criticize_or_die {
    my ($obj, $mess) = @_;
    @_ == 2 or croak arity_miss 0+@_, 2;
    my @errs = ref $obj eq 'ARRAY' ? criticize(@$obj) : criticize($obj);
    if (@errs) {
        die join("\n    ", $mess, @errs) . "\n";
    }
}

##### Backend

 # Current state, loaded if necessary
my $index;
my %events;
 # Editable.  Changes will be validated then committed in one event.
my %write_items;
my $event;

 # Must wrap this around any access.
my $transaction;
sub READ () { return 1; }  # LOCK_SH
sub WRITE () { return 2; }  # LOCK_EX
sub transaction {
    my ($mode, $proc) = @_;
    @_ == 2 or arity_miss 0+@_, 1;
    $mode eq READ or $mode eq WRITE or die "Invalid transaction mode '$mode' (must be READ or WRITE)";
    if (defined $transaction) {
        $transaction == $mode or die "Cannot nest transactions of different types.";
        return $proc->();
    }
    $transaction = $mode;
     # Start
    open my $LOCK, '>', "$datadir/lock" or croak "Failed to acquire $datadir/lock: $!\n";
    flock $LOCK, $lock_mode or croak "Failed to acquire $datadir/lock: $!\n";
    my @r;
    eval {
         # Generate necessary structure
        mkdirs "$datadir/events";
        if (-e "$datadir/index.json") {
            $index = decode_json slurp "$datadir/index.json";
             # Is this check worth the performance hit?  Profiling needed.
            criticize_or_die [$index, $index_schema], "Internal error: index.json is not valid!";
        }
        else {
            $index = {
                latest_event => null,
                items => {},
            };
        }
        my $event = {
            started_at => iso_datetime(gmtime),
            source => { interface => 'unknown' },
            request => null,
            response => null,
        };
         # Do the actual code
        @r = $proc->();
         # Finish event structure
        while (1) {
            $event->{id} = iso_datetime(gmtime) . '_' . sprintf("%04x", int(rand(65536)));
            last unless -e "$datadir/events/$event->{id}.json";
        }
        if ($transaction == WRITE) {
            for (keys %write_items) {
                if ($write_items{$_}{name} ne $_) {
                    die "Changing name of item is NYI, sorry\n";
                }
                my $old_event = $events->{$index->{items}{$_}};
                if (!defined $old_event or !deep_eq($write_items{$_}, $old_event->{changes}{$_}{item})) {
                    criticize_or_die $write_items{$_};
                    $event->{changes}{$_} = {
                        previous => defined $old_event ? $old_event->{id} : null,
                        item => $write_items{$_};
                    };
                    $index->{items}{$_} = $event->{id};
                }
            }
        }
        $event->{finished_at} = iso_datetime(gmtime);
         # Commit event
    };
    my $mess = $@;
     # Clear data
    $index = undef;
    %events = ();
    %items = ();
    $transaction = undef;
     # Release lock and finish dying if necessary
    flock $LOCK, 8 or $mess .= "Failed to release $datadir/lock: $!\n";
    close $LOCK or $mess .= "Failed to close $datadir/lock: $!\n";
    $mess and die $mess;
     # Annoying contextual return hack
    if (@r == 1) {
        return $r[0];
    }
    else {
        return @r;
    }
};

 # Inside a transaction, returns a read-writable item.
sub item {
    my ($name) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    defined $name or croak "Name passed to item() as parameter is undefined.";
    $in_transaction or croak "item('$name') called outside of transaction.";
    if (!defined $index) {
        $index = decode_json slurp("$datadir/index.json");
         # This may not be worth the performance hit.
        criticize_or_die [$i, $index_schema], "Internal error: index.json is not valid!";
    }
    if (exists $index->{items}{$name}) {
    }
}


 # Only to be used in a transaction
sub read_index {
    return if defined $index;
    my $i = decode_json slurp("$datadir/index.json");
    criticize_or_die [$i, $index_schema], "Internal error: index.json is not valid!";
    $index = $i;
}

sub read_event {
}

sub read_item {
    my ($name) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    defined $name or croak arity_miss
    return $items{$name} if exists $items{$name};
    read_index;
    my $event = $index->{items}{name} // return undef;
    read_event($event);
}

sub have_item {
    my ($name) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    return transaction sub {
        exists $items{$name} || -e name_file $name;
    };
}

sub read_item {
    my ($name) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    my $filename = name_file $name;
    exists $items{$name} and return $items{$name};
    criticize_or_die [$name, 'name', '(name given to read_item)'], 'Name given to read_item is invalid.';
    return transaction sub {
        -e $filename or croak "$name is not a registered item";
        my $json = slurp $filename;
        my $item = decode_json $json;
        criticize_or_die $item, "$filename contains invalid data:";
        return $items{$name} = $item;
    };
}

sub write_item {  # TODO: update links, dates
    my ($item) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    criticize_or_die $item, "Provided data did not pass validation:";
    my $json = encode_json $item;
    return transaction sub {
        $to_write{encode_name($item->{name})} = $json;
        $items{$item->{name}} = $item;
        return 1;
    };
}

sub delete_item {  # TODO: update links
    my ($name) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    return transaction sub {
        $to_write{encode_name($name)} = undef;
        return 1;
    };
}

sub update_item {  # TODO: update links, name
    my ($name, $proc) = @_;
    @_ == 2 or croak arity_miss 0+@_, 1;
    criticize_or_die [$name, 'name', '(name given to update_item)'], 'Name given to update_item is invalid.';
    ref $proc eq 'CODE' or croak "Second parameter given to update_item is not a CODE ref.";
    return transaction sub {
        my $item = $proc->(read_item $name);
        criticize_or_die $item, "Item returned from procedure given to update_item did not pass validation:";
        $item->{name} eq $name or croak "Procedure given to update_item changed the item's name (this is NYI).";
        write_item $item;
    };
    return 1;
}

sub all_names {
    @_ == 0 or croak arity_miss 0+@_, 0;
    my $dir = "$datadir/things";
    return transaction sub {
        opendir my $D, $dir or croak "Could not open $dir: $!\n";
        my @filenames = map {
            /^(.*)\.json$/ ? $1 : ();
        } readdir $D;
        closedir $D or croak "Could not close $dir: $!\n";
        return map decode_name($_), @filenames;
    };
}
sub all_items {
    @_ == 0 or croak arity_miss 0+@_, 0;
    my $copy = !$in_transaction;
    return transaction sub {
        for (all_names) {
            read_item($_);
        }
        return $copy ? {%items} : \%items;  # Please don't modify
    };
}

sub validate_everything {
    @_ == 0 or croak arity_miss 0+@_, 0;
    return transaction sub {
        all_items;
        my @errs;
        for (keys %items) {
            $items{$_}{name} eq $_ or push @errs, "Name property of $_ doesn't match its name.";
            my @es = criticize $items{$_};
            if (@es) {
                push @errs, "Invalid data in $_:";
                push @errs, map "    $_", @es;
            }
             # TODO: validate links
        }
        return @errs;
    };
}


##### Raw JSON API

sub raw_add {
    my ($text) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    my $item = decode_json $text;
    return transaction sub {
        have_item $item->{name} and croak "An item named $item->{name} is already registered";
        criticize_or_die $item, "Input to 'add' didn't pass validation.";
        my $filename = name_file $item->{name};
        write_item $item;
        return 1;
    };
}
sub raw_show {
    my ($name) = @_;
    @_ == 1 or croak arity_miss 0+@_, 1;
    my $item = read_item $name;
    return encode_json $item;
}
=cut
1;
